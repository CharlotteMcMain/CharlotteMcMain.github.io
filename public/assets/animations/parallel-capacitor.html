<div style="max-width:980px">
<svg id="circuit" viewBox="0 0 980 420" width="100%" xmlns="http://www.w3.org/2000/svg">
  <style>
    .wire { fill:none; stroke:#111; stroke-width:6; stroke-linecap:round; stroke-linejoin:round; }
    .thin { stroke-width:4; }
    .plate { stroke:#111; stroke-width:7; stroke-linecap:round; }
    .label { font: 28px system-ui, -apple-system, Segoe UI, Roboto, Arial; fill:#111; }
    .electron { fill:#1e88e5; opacity:0.95; }
    .pile { fill:#1e88e5; opacity:0.95; }
  </style>

  <!-- MAIN OUTER LOOP (closed) -->
  <path class="wire" id="loop"
        d="M140 80 H860
           V340
           H140
           Z" />

  <!-- Switch gap + lever (purely visual) -->
  <circle cx="430" cy="80" r="7" fill="#111"/>
  <circle cx="550" cy="80" r="7" fill="#111"/>
  <path class="wire thin" d="M445 70 L535 90" />/workspaces/CharlotteMcMain.github.io/public/assets/animations/parallel-capacitor.html
  <text class="label" x="485" y="45">S</text>

  <!-- Battery (visual only) -->
  <line class="plate" x1="140" y1="150" x2="210" y2="150"/>
  <line class="plate" x1="140" y1="178" x2="195" y2="178"/>
  <text class="label" x="95" y="170">V</text>

  <!-- Branch to capacitor A -->
  <path class="wire thin" id="branchA" d="M620 80 V160" />
  <line class="plate" x1="585" y1="170" x2="655" y2="170"/>
  <line class="plate" x1="585" y1="200" x2="655" y2="200"/>
  <path class="wire thin" d="M620 210 V340" />
  <text class="label" x="605" y="255">A</text>

  <!-- Branch to capacitor B -->
  <path class="wire thin" id="branchB" d="M760 80 V160" />
  <line class="plate" x1="725" y1="170" x2="795" y2="170"/>
  <line class="plate" x1="725" y1="200" x2="795" y2="200"/>
  <path class="wire thin" d="M760 210 V340" />
  <text class="label" x="745" y="255">B</text>

  <!-- "Targets" for piling (invisible points just above top plates) -->
  <circle id="pileA" cx="620" cy="162" r="2" fill="none"/>
  <circle id="pileB" cx="760" cy="162" r="2" fill="none"/>

  <!-- Electron layer -->
  <g id="electrons"></g>
  <!-- Pile layer (so stacked dots sit above wires) -->
  <g id="piles"></g>

  <text class="label" x="440" y="405">Fig. 1</text>
</svg>
</div>

<script>
(() => {
  const svg = document.getElementById("circuit");
  const loop = document.getElementById("loop");
  const branchA = document.getElementById("branchA");
  const branchB = document.getElementById("branchB");
  const electronsG = document.getElementById("electrons");
  const pilesG = document.getElementById("piles");

  const pileA = document.getElementById("pileA");
  const pileB = document.getElementById("pileB");

  const L = loop.getTotalLength();
  const LA = branchA.getTotalLength();
  const LB = branchB.getTotalLength();

  // Where on the loop are the branch junctions?
  // We'll choose approximate "s" (0..1) locations by sampling positions near the branch x values.
  function findSNearX(targetX, targetY, samples=1000) {
    let best = { s:0, d:1e9 };
    for (let i=0;i<=samples;i++){
      const s = i/samples;
      const p = loop.getPointAtLength(s*L);
      const d = (p.x-targetX)*(p.x-targetX) + (p.y-targetY)*(p.y-targetY);
      if (d < best.d) best = { s, d };
    }
    return best.s;
  }

  // Junction points near the top rail where branches drop down
  const sJuncA = findSNearX(620, 80);
  const sJuncB = findSNearX(760, 80);

  // Piling counters (to offset dots so they "stack")
  let pileCountA = 0;
  let pileCountB = 0;

  // Electron “current” settings
  const N = 70;                 // how full the wire looks
  let baseSpeed = 0.22;         // loop revolutions per second-ish (scaled in code)
  let charge = 0;               // 0..1
  const chargeRate = 0.05;      // how fast we "fill" (bigger = faster piling)

  // Create electrons evenly spaced around the loop
  const electrons = Array.from({length:N}, (_, i) => {
    const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    c.setAttribute("r", "4.2");
    c.setAttribute("class", "electron");
    electronsG.appendChild(c);

    return {
      el: c,
      state: "loop",   // "loop" | "toA" | "toB" | "piled"
      s: i / N,        // position on loop (0..1)
      t: 0,            // position on branch (0..1)
      target: null
    };
  });

  function setCirclePos(circle, x, y) {
    circle.setAttribute("cx", x.toFixed(2));
    circle.setAttribute("cy", y.toFixed(2));
  }

  // Convert pile target circle to coords
  function getTargetCoords(targetEl, pileIndex) {
    const x = parseFloat(targetEl.getAttribute("cx"));
    const y = parseFloat(targetEl.getAttribute("cy"));
    // Stack them in a neat “bank” above the plate:
    // alternate left/right and step upward slightly
    const dx = ((pileIndex % 10) - 4.5) * 4.5;   // spread sideways
    const dy = Math.floor(pileIndex / 10) * 6.0; // stack upward
    return { x: x + dx, y: y - dy };
  }

  // Divert an electron that is near a junction into A or B
  function maybeDivert(e) {
    if (charge >= 1) return;

    // Probability increases as charging progresses, but keeps going until "full"
    const divertChance = 0.004 + 0.02 * (1 - charge);

    // Prefer A and B equally (you can weight this if you want)
    if (Math.random() < divertChance) {
      // Choose A or B based on which junction it is near (or random if near both)
      const distA = Math.abs(e.s - sJuncA);
      const distB = Math.abs(e.s - sJuncB);

      let choose = "A";
      if (distB < distA) choose = "B";
      else if (Math.random() < 0.5) choose = (distA < distB ? "A" : "B");

      e.state = (choose === "A") ? "toA" : "toB";
      e.t = 0;
    }
  }

  // When an electron reaches the plate, convert it to a piled dot and stop it
  function pileElectron(e, which) {
    e.state = "piled";
    // Make a new circle for the pile so the original can be "removed"
    const p = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    p.setAttribute("r", "4.2");
    p.setAttribute("class", "pile");

    let idx;
    if (which === "A") idx = pileCountA++;
    else idx = pileCountB++;

    const targetEl = (which === "A") ? pileA : pileB;
    const {x, y} = getTargetCoords(targetEl, idx);
    setCirclePos(p, x, y);
    pilesG.appendChild(p);

    // hide moving electron
    e.el.setAttribute("opacity", "0");
  }

  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.03, (now - last) / 1000);
    last = now;

    // "Charge up" over time, slowing current as it approaches full
    charge = Math.min(1, charge + chargeRate * dt);
    const speedScale = 0.15 + 0.85 * (1 - charge); // slows down toward the end
    const loopSpeed = baseSpeed * speedScale;

    for (const e of electrons) {
      if (e.state === "loop") {
        e.s = (e.s + loopSpeed * dt) % 1;
        const p = loop.getPointAtLength(e.s * L);
        setCirclePos(e.el, p.x, p.y);

        // Only divert if near the top rail AND not "full"
        // (This makes it feel like electrons peel off into the capacitors.)
        const nearTop = p.y < 90;
        if (nearTop) maybeDivert(e);

      } else if (e.state === "toA") {
        // Move down branch A toward plate
        e.t += (1.2 + 1.5*(1-charge)) * dt;
        const tClamped = Math.min(1, e.t);
        const p = branchA.getPointAtLength(tClamped * LA);
        setCirclePos(e.el, p.x, p.y);
        if (tClamped >= 1) {
          pileElectron(e, "A");
        }

      } else if (e.state === "toB") {
        e.t += (1.2 + 1.5*(1-charge)) * dt;
        const tClamped = Math.min(1, e.t);
        const p = branchB.getPointAtLength(tClamped * LB);
        setCirclePos(e.el, p.x, p.y);
        if (tClamped >= 1) {
          pileElectron(e, "B");
        }
      }
    }

    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);
})();
</script>